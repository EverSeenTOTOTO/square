use crate::errors::*;

use lazy_static::lazy_static;
use regex::Regex;

#[derive(Debug)]
pub struct Position {
    pub line: usize,
    pub column: usize,
    pub cursor: usize,
}

impl Position {
    pub fn new(line: usize, column: usize, cursor: usize) -> Self {
        Self {
            line,
            column,
            cursor,
        }
    }

    pub fn clone(&self) -> Self {
        Self::new(self.line, self.column, self.cursor)
    }
}

#[derive(Debug, PartialEq)]
pub enum TokenName {
    BOOL,
    EOF,
    ID,
    NUM,
    OP,
    STR,
    WHITESPACE,
}

#[derive(Debug)]
pub struct Token<'a> {
    pub name: TokenName,
    pub source: &'a str,
    pub position: Position,
}

impl<'a> Token<'a> {
    pub fn new(name: TokenName, source: &'a str, position: Position) -> Self {
        Self {
            name,
            source,
            position,
        }
    }
}

pub fn make_token<'a>(name: TokenName, source: &'a str, pos: &mut Position) -> Token<'a> {
    let snapshot = pos.clone();

    pos.column += source.len();
    pos.cursor += source.len();

    Token::new(name, source, snapshot)
}

type RaiseResult<'a> = Result<Token<'a>, ParseError>;

pub fn raise_token<'a>(input: &'a str, pos: &mut Position) -> RaiseResult<'a> {
    if pos.cursor >= input.len() {
        return Ok(make_token(TokenName::EOF, "", pos));
    }

    lazy_static! {
        static ref STRING_PIVOT: Regex = Regex::new("'").unwrap();
        static ref NUMBER_PIVOT: Regex = Regex::new("[0-9]").unwrap();
        static ref IDENT_PIVOT: Regex = Regex::new("[a-zA-Z_]").unwrap();
        static ref OP_PIVOT: Regex = Regex::new(r"[.,=!+\-*/<>^%]").unwrap();
        static ref WHITESPACE_PIVOT: Regex = Regex::new(r"\s+").unwrap();
    }

    let pivot = &input[pos.cursor..=pos.cursor];

    match pivot {
        "'" => raise_string(input, pos),
        _ if NUMBER_PIVOT.is_match(pivot) => raise_number(input, pos),
        _ if IDENT_PIVOT.is_match(pivot) => raise_ident(input, pos),
        _ if OP_PIVOT.is_match(pivot) => raise_operator(input, pos),
        _ if WHITESPACE_PIVOT.is_match(pivot) => raise_whitespace(input, pos),
        _ => todo!(),
    }
}

lazy_static! {
    static ref STRING_PATTERN: Regex = Regex::new(r"'(?:\\'|[^'])*'").unwrap();
}

pub fn raise_string<'a>(input: &'a str, pos: &mut Position) -> RaiseResult<'a> {
    let source = STRING_PATTERN
        .find(input)
        .ok_or_else(|| ParseError::InvalidToken(pos.clone()))?
        .as_str();
    Ok(make_token(TokenName::STR, source, &mut pos.clone()))
}

lazy_static! {
    static ref NUMBER_PATTERN: Regex = Regex::new("[0-9]+").unwrap();
}

fn raise_number<'a>(input: &'a str, pos: &mut Position) -> RaiseResult<'a> {
    let source = NUMBER_PATTERN
        .find(input)
        .ok_or_else(|| ParseError::InvalidToken(pos.clone()))?
        .as_str();
    Ok(make_token(TokenName::NUM, source, &mut pos.clone()))
}

lazy_static! {
    static ref ID_REGEX: Regex = Regex::new(r"^[a-zA-Z_][a-zA-Z0-9_]*").unwrap();
    static ref BOOL_REGEX: Regex = Regex::new(r#"^(?:true|false)$"#).unwrap();
}

fn raise_ident<'a>(input: &'a str, pos: &mut Position) -> RaiseResult<'a> {
    if let Some(matched) = ID_REGEX.find(&input[pos.cursor..]) {
        let text = matched.as_str();
        return if BOOL_REGEX.is_match(text) {
            Ok(Token::new(TokenName::BOOL, text, pos.clone()))
        } else {
            Ok(Token::new(TokenName::ID, text, pos.clone()))
        };
    }

    Err(ParseError::InvalidToken(pos.clone())
}

lazy_static! {
    static ref OP_REGEX: Regex =
        Regex::new(r#"^(\.\.?\.?|\/\[|(=|!|-|\+|\*|\/|<|>|\^|%)=?) "#).unwrap();
}

fn raise_operator<'a>(input: &'a str, pos: &mut Position) -> RaiseResult<'a> {
    todo!()
}

lazy_static! {
    static ref COMMENT_REGEX: Regex = Regex::new(r#";([^;\\\r\n]|\\;)*;?"#).unwrap();
}

fn raise_whitespace<'a>(input: &'a str, pos: &mut Position) -> RaiseResult<'a> {
    todo!()
}
